# RISC 와 CISC

#### CISC (Complex Instruction Set Computer)
CISC는 필요한 모든 명령어 셋을 갖추도록 설계된 마이크로프로세서에 관련되는 용어로서, 요구되는 능력을 가장 효율적인 방법으로 제공했었다. 
이름에서 알 수 있듯이 컴퓨터에 주어진 CISC명령은 매우 작기 때문에, 그 당시 메모리 부족의 문제점을 보완할 수 있었다.

그러나 그 후, 명령어셋 자체를 가장 자주 사용되는 명령어만으로 갯수를 줄임으로서 대부분의 활용업무 면에서 소요되는 시간을 줄일 수 있는 방법이 고안되었는데,
이것을 RISC라고 불렀다. 그러다 보니, 이러한 RISC 프로세서와 모든 명령어 셋을 갖추고 있는 컴퓨터를 구별할 수 있는 말이 필요하게 되었는데, 그래서 CISC 라는 용어를 사용하게 되었다.

IBM의 System/6000 기종과 매킨토시 컴퓨터에 사용되고 있는 PowerPC라는 마이크로프로세서가 바로 RISC 형태의 프로세서이며, 펜티엄을 포함한 인텔 계열의 CPU는 CISC 프로세서이다. RISC는 CISC의 길고 복잡한 명령어 설계를 가져다 짧고, 처리가 빠른 여러개의 명령어로 바꾸었다.

* CISC 접근
	CISC 아키텍쳐의 주요 목표는 가능한 적은 수의 명령으로 작업을 수행해야한다. 이러한 목표는 프로세서 하드웨어를 각 연산을 이해하고 실행할 수 있게끔 제작함으로써 이뤄진다.
	이런 특정한 작업에선 CISC는 특정한 명령어를 준비할 것이다. ("MULT" 라고 부른다) 이 명령이 실행될 때 하나의 실행 유닛에서 명령은 두 값을 각각의 레지스터로 이동시킨 후, 두 피연산자를 곱해서 적절한 레지스터에 결과를 저장한다. 즉 두 수를 곱하는 모든 작업은 하나의 명령으로 완료된다. 

* 인텔계열 CPU

#### RISC (Complex Instruction Set Computer)
RISC는 적은 수의 컴퓨터 명령어를 수행하도록 설계된 마이크로프로세서로서, 좀더 빠른 속도로 동작 될 수 있다. 컴퓨터는 수행해야 할 각 명령어 형태마다 트랜지스터와 회로들이 추가되어야 하기 때문에, 많은 수의 컴퓨터 명령어 셋을 갖춘 마이크로 프로세서는 만들기도 복잡하고 실행속도도 늦은 경향이 있다.

RISC의 기본 개념은 단순화(크기나 복잡성면에서)에 있다. 이는 마이크로프로세서를 좀 더 사려깊게 설계하도록 촉발하였다. 

* RISC 접근
RISC 프로세서들은 하나의 클럭안에 실행 될 수 있는 간단한 명령들만 사용한다. 따라서 위에서 사용한 MULT의 명령은 3부분으로 나뉘어 질 수 있다.
메모리 뱅크의 데이터를 레지스터로 이동시키는 "LOAD",  레지스터의 위치한 두 값은 곱을 구하는 "PROD", 레지스터의 데이터를 메모리뱅크로 이동시키는 "STORE". 프로그래머는 4줄의 어셈블리 코드를 작성해야할 필요가 있다.

* RISC의 장점
각각의 명령은 실행하기 위해 단지 한클럭 사이클만 필요로하기 때문에, 
전체 프로그램은 여러 사이클의 "MULT"명령만큼의 총 수행 시간에 근접하게 실행될 것이다.

이런 RISC의 "축약 명령어(Reduced Instruction)"는 복합 명령어에 비해 적은 수의 트랜지스터를 요구하면서 범용 레지스터들을 위한 좀 더 많은 공간을 남겨둔다.
결국 모든 명령어들은 단일 형태로 실행되기 때문에 파이프라이닝*(Pipelining)이 가능하게 된다.

나누어진 "LOAD"와 "STORE" 명령어는 실제로 컴퓨터가 수행해야 하는 작업의 총량을 감소시켜준다. CISC 스타일의 "MULT"명령이 실행된 이후 프로세서는 자동적으로 레지스터들을 지운다. 만약 피연산자 값 중에 하나가 다른 계산에서 사용되고자 한다면 프로세서는 메모리 뱅크에서 레지스터로 그 데이터를 다시 읽어와야만 한다. RISC에서는 다른 새로운 값이 저장되기 전까지 데이터가 그대로 남아있게 된다.
* ARM CPU

#### CISC과 RISC의 차이
CISC | RISC
-----|-----
하드웨어가 강조됨 | 소프트웨어가 강조됨
여러클럭의 복합 명령어를 포함 | 오직 단일 클럭의 축약명령어만 포함
Memory to Memory : "LOAD", "STORE"가 각 명령어들 안에서 수행됨 | Register to Register :"LOAD", "STORE"를 독립적인 명령으로 사용함
작은 코드 크기, 단위시간동안 높은 사이클 | 단위시간동안 낮은 사이클 수, 큰 코드 크기
축약 명령어 저장을 위해 트랜지스터가 사용됨 | 메모리 레지스터에 보다 많은 트랜지스터가 사용됨

** 파이프라이닝되지 않은 프로세서는, 다시 말해 파이프라인 스테이지가 분절되지 않은 프로세서는 한 명령어가 인출 - 디코드 - 실행 - 쓰기가 끝나기 전에는 다른 명령어가 파이프라인에 투입될 수 없다.
다시 말해 위의 네 단계에 해당하는 하드웨어가 모두 명령어 하나에 매달려, 그 명령어가 끝나기만을 기다리는 것.
