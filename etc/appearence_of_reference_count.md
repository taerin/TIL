# 복사 정책
Reference Counting이 왜 등장했는지 아나요? 모른다면 이 글을 보세요 우캬캬캬.
Reference Counting을 제대로 이해하려면 먼저 복사정책에 대해서 공부해야 합니다.

프로그래밍에서 복사 정책은 크게 3가지가 있습니다.
	1) 깊은 복사 (clone)
	2) 얕은 복사 (참조 복사)
	3) 복사 금지

그럼 하나씩 살펴볼까요?

## 1. 깊은 복사
깊은 복사는 C++의 기본 복사 정책입니다. 자바에서의 복사정책이 얕은 복사 즉, 참조 복사(얕은 복사)인것과 대비되지요.
예를들어, C++에서 Point 인스턴스인 p1을 생성하고 p2로 대입했다고 가정합시다. 코드로는 p2 = p1 이 되겠지요. 
C++ 의 기본 대입 연산의 기본은 깊은 복사이기 때문에 기존 p1과 동일한 내용을 가진 객체가 새로 생성됩니다. C++에서 얕은복사(참조 복사)를 하고싶다면 Pointer를 사용하면 됩니다.

### 장점
그렇다면 깊은 복사의 장점은 무엇일까요? __안전하다__
동일한 참조를 가지고 있지 않기때문에 한 레퍼런스를 통해 객체가 내용을 변경해도 다른 객체에 영향을 주지않는다는 점에서 안전합니다.

### 단점
그렇다면 단점은? 1) 복사시 성능 저하 2) 동일한 내용의 객체라면 불필요한 중복이 발생한다는 두가지 단점이 있겠군요.
복사시 성능이 저하된다는 점은 만약 객체의 크기가 크다면 더 문제가 됩니다. 또 동일한 내용을 가진 객체가 두개가 있을 필요가 없다는 점에서 중복의 문제도 있겠군요.

## 2. 얕은 복사(참조 복사)
자바의 기본 복사 정책인 얕은 복사(참조 복사)입니다. 깊은 복사처럼 동일한 객체를 새로이 생성하는 것이 아닌 기존의 참조를 동일하게 가리키는 것을 말합니다.

### 장점
참조 복사는 동일 참조만을 가지면 되므로 복사에 대한 비용이 들지 않습니다.

### 단점
단점으로는 __안전하지 않다__ 라는 점이겠지요. 다른 레퍼런스를 통한 변경으로 인한 버그의 발생에서 안전하지 않습니다.  

다른 레퍼런스를 통한 변경으로 문제가 되는 것은 __멀티쓰레드 환경__에서 더 심각한 문제가 될수 있습니다. 
이러한 문제는 객체가 생성된 이후로 속성을 변경할 수 없는 불변객체가 탄생한 배경이기도 합니다.

## Dangling Pointer(댕글링 포인터)
댕글링 포인터 문제는 얕은 복사(참조 복사)에서 발생하는 문제입니다. 
댕글링 포인터 문제란, 포인터가 여전히 해제된 메모리 영역을 가리키고 있다면, 이러한 포인터를 댕글링 포인터(Dangling Pointer)라고 합니다.

예를들어 두 개의 레퍼런스가 동일한 객체를  가지고 참조하고 있는 상황에서, 한 레퍼런스가 객체를 파괴한다면 또 다른 레퍼런스는 참조하고 있는 객체가 없어지는 문제가 발생하는 것이죠.

## Reference Counting의 등장 
이러한 문제를 해결하기 위해서 등장한 것이 __Reference Counting__ 입니다. 참조계수를 증감하여 객체의 수명을 관리하는 방법입니다. 
Reference Counting의 방법으로는 크게 1) ARC 와 2)GC 방법이 있는데 각 방법에 대한 특징은 이전 TIL에 정리해 두었으니 참고해보세요.

### Reference Counting의 문제점
상호 참조발생 시 참조 계수가 0이 되지 못하여 메모리 누수가 발생할 수 있습니다. 이러한 문제는 강한 참조 / 약한 참조로 나누어 해결할 수 있습니다. 이 내용은 다음 TIL에서 다루도록 하겠습니다. 
