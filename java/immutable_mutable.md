# 불변객체(Immutable Object)

불변객체는 생성 후 그 상태를 바꿀 수 없는 객체입니다.  객체 전체가 불변인 것도 있고, C++ 에서 const 데이터 멤버를 사용하는 경우와 같이 일부 속성만 불변인 것도 있습니다. 불변 객체의 초기상태는 대개 생성 시에 결정되지만, 객체가 실제로 사용되는 순간까지 늦추기도 합니다.

#### 불변객체의 복사
불변객체는 객체를 복제할 때 객체전체가 아니라 단순히 주소만 복사하고 끝납니다.
주소를 복사하는 것은 보통 객체 그 자체보다 훨씬 작아서(포인터 크기), 메모리가 절감되며 프로그램의 성능에도 좋습니다.

가변 객체는 참조 복사 기법으로 다루기 곤란한데, 이유는 가변 객체의 참조를 가지고 있는 모든 장소에서 그 영향을 받기 때문입니다.
이것이 의도한 동작이 아니라면 참조를 가지고 있는 다른 장소에 변경 사실을 통지하고 대처하는 추가 대응이 필요하기 때문이죠.
이러한 경우 비용은 조금 들지만 참조가 아닌 객체 전체를 방어적복사(defensive copy)하는 방법으로 대응 할 수 있습니다.
* 방어적 복사란? 객체 상태를 전부 복사하여 새로운 객체를 만들어내는 것.
또는 Observer 패턴을 가변객체의 변경에 대처하는 방법으로 사용할 수도 있습니다.

객체 전체 대신 참조를 복제하는 기법은 인턴(intern, 문자열 객체를 마들면 매번 메모리에 새로운 객체가 만들어지는데 이를 인턴하여 문자열 풀 - String Pool-에 저장하고 그 뒤 같은 문자열이 호출되면 풀에서 참조를 복사해 반환하는 기법)으로 알려져 있다. 인턴이 사용되고 있다면 2개의 객체가 같다고 판단되는 경우는 참조가 같은 경우다.

#### 불변객체는 가변객체보다 스레드 세이프하다
불변 객체는 멀티 스레드 프로그래밍에서도 유용합니다. 데이터가 불변 객체에 저장돼 있다면, 복수의 스레드에 의해서 특정한 스레드의 데이터가 변경될 우려 없이 데이터에 접근 할 수 있습니다.  (특히 자바에서 static final 은 스레드 안정성을 보장합니다.)
즉 베타제어(mutual exclusion)를 할 필요가 없습니다. 

#### 카피 온 라이트(Copy-On-Write)  
이용자가 시스템에 객체를 복제하도록 명하면 복사 대신 동일한 객체를 가리키는 참조를 만듭니다. 그리고 이용자가 그 참조를 통해 객체를 변경하면 그때 진짜 복제를 만들고 그것을 가리키는 참조를 다시 생성하는 방법을 말합니다.
