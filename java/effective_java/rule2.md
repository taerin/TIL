# 규칙2: 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라
-----
정적 팩터리나 생성자는 같은 문제를 갖고있다. 선택적 인자가 많은 상황에 잘 적응하지 못한다는 것이다.
포장 판매되는 음식에 붙어있는 영양 성분표를 나타내는 클래스를 예로 들어보자. 이 성분표에 반드시 포함되어야 하는 항목은 몇가지 되지 않는다.
총 그러나 선택적인 항목은 20개가 넘는다.
이러한 클래스에는 어떤 생성자가 정적 팩터리 메서드가 적합할까?

## 점층적 생성자 패턴(telescoping constructor pattern)
보통 프로그래머들은 이러한 상황에 __ 점층적 생성자 패턴(telescoping constructor pattern)__ 을 적용한다. 
필수 인자만 받는 생성자를 하나 정의하고, 선택적 인자를 하나 받는 생성자를 추가하고, 거기에 두개의 선택적 인자를 받는 생성자를 추가하는 식으로 생성자를 쌓아 올리듯 추가하는 것이다. 결국 모든 선택적 인자를 다 받는 생성자를 추가하면 정의는 끝나게 된다.
하지만 __ 점층적 생성자 패턴 __ 을 사용하게 되면 설정할 필요가 없는 필드에도 인자를 전달해야 하는 경우가 생긴다.
요약하자면, 점층적 생성자 패턴은 잘 동작하지만 인자수가 늘어나면 클라이언트 코들르 작성하기 어려워지고, 무엇보다 읽기 어려운 코드가 되고 만다. 

## 자바빈 패턴 (JavaBeans)
인자없는 생성자를 호출하여 객체부터 만든 다음 설정 메서드(setter methods)들을 호출하여 필수 뿐만 아니라 선택적 필드의 값 까지 채우는 것이다.
자바빈 패턴에는 점층적 생성자 패턴에 있던 문제는 없다. 작성해야 하는 코드의 양이 조금 많아질 수 있지만 객체를 생성하기도 쉬우며 읽기도 좋다.
그러나 불행히도 자바빈 패턴에는 심각한 단점이 있다. 
1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성(consistency)이 일시적으로 깨질 수 있다는 것이다.
생성자의 인자가 유효한지 검사하여 일관성을 보장하는 단순한 방법을 여기서는 사용할 수 없다. 
이와 관련된 또 다른 문제는 자바빈 패턴으로는 변경 불가능(immutable) 클래스를 만들 수 없다는 것이다. 이는 스레드 안정성을 제공하기 위해 해야 할 일도 더 많아진다.
이 문제는 생성이 끝난 객체는 얼리고(freezing) 얼지 않은 객체는 사용할 수 없도록 하는 코드를 수작업으로 추가해서 방지할 수 도있다.
하지만 이방법을 까다로우며 거의 쓰이지도 않는다. 게다가 실행 도중에 오류가 발생할 가능성이 있는데, 컴파일러 입장에서는 프로그래머가 "객체를 얼리는" 메서드를 제대로 호출 했는지 검사할 방도가 없기 때문이다.

## 빌더 패턴(Builder)
다행인 것은, 점층적 생성자 패턴의 안정성에 자바빈 패턴의 가독성을 결합한 세번째 대안이 있다는 것이다.
바로 빌더(Builder) 패턴이다. 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에(또는 정적 팩터리 메서드에) 전부 전달하여 빌더 객체(builder object)를 만든다. 그런 다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다. 그리고 마지막으로 아무런 인자 없이 build 메서드를 호출하여 변경 불가능(immutable) 객체를 만드는 것이다. 
빌더 클래스는 빌더가 만드는 객체 클래스의 정적 클래스로 정의한다. 그 실제 코드를 보자

``` java
public class NutritionFacts{
	private final int servingSize;
	private final int servings;
	prinvate final int calories;
	private final int fat;

	public static class Builder{
	// 필수인자
		private final int servingSize;
		private final int servings;
	// 선택적 인자- 기본값으로 초기화
		private int calories = 0;
		private int fat = 0;

		public Builder(int servingSize, int servings){
			this.servingSize = servingSize;
			this.servings = servings;
		}

		public Builder calories (int val)
		{calories = val; return this;}

		public Builder fat (int val)
		{fat = val; return this;}

		public NuturitionFacts build(){
			return new NutritionFacts(this);
		}
	}

	private NutritionFacts(Builder builder){
		servingSize = builder.servingSize;
		servings = builder.servings;
		calories = builder.calories;
		fat = builder.fat;
	}
}
```

NutritionFacts 객체가 변경 불가능하다는 사실, 그리고 모든 인다의 기본값ㅇ이 한곳에 모여있다는 것에 유의하기 바란다. 빌더에 정의된 설정메서드는 빌더 객체 자신을 반환하므로, 설정 메서드를 호출하는 코드는 쭉 이어서 쓸 수 있다.

```  java
NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
							.calories(100)
							.fat(20)
							.build();
```

위 코드는 작성하기도 쉽고 그리고 무엇보다 일기 쉽다. Ada나 파이썬 같은 언어는 선택적 인자에 이름을 붙일 수 있도록 허용하는데 그것과 비슷한 코드를 작성할 수 있기 때문이다.
생성자와 마찬가지로, 빌더 패턴을 사용하면 인자에 불변식(invariant)을 사용할 수 있다. build 메서드 안에서 해당 불변식이 위반되었는지를 검사할 수 있는 것이다. 빌더 객체에서 실제 객체로 인자가 복사된 다음에 불변식들을 검사할 수 있다는것, 그리고 그 불변식을 빌더 객체의 필드가 아니라 실제 객체의 플드를 두고 검사할 수 있다는 것은 중요하다. 불변식을 위반한 경우, build 메서드는 IllegalStateException 을 던져야 한다.이 예외 객체를 살펴보면 어떤 불변식을 위반했는지 알아낼 수도 있어야 한다.
여러 인자에 관련된 불변식을 강제하는 또 한가지 방법은 불변식이 적용될 값 전부를 인자로 받는 설정자 메서드(setter method)를 정의하는 것이다.
이 설정 메서드는 불변식이 만족되지 않으면 IllegalArgumentException을 던져야 한다. 이렇게 하면 build가 실제로 호출되기 전에 불변식을 깨뜨리는 인자가 되었다는 사실을 신속하게 알 수 있다는 장점이 있다.

생성자와 비교했을때 빌더패턴이 갖는 또 한가지 작은 장점은 빌더 객체는 여러개의 varargs 인자를 받을 수 있다는 것이다. 생성자는 메서드와 마찬가지로 하나의 varargs만 인자로 가질 수 있다. 하지만 빌더는 인자마다 별도의 설정 메서드를 사용하므로, 설정 메서드마다 하나씩, 필요한 만큼 많은 varargs인자를 사용할 수 있다.

또한 빌더패턴은 유연하다. 하나의 빌더 객체로 여러 객체를 만들 수 있고 어떤 필드의 값은 자동으로 채울 수도 있다 
인자가 설정된 빌더는 훌륭한 추상적 팩터리다. 다시말해서 클라이언트는 그런 빌더를 어떤 메서드에 넘겨서, 해당 메서드가 클라이언트에게 하나 이상의 객체를 만들어 주도록 할 수 있다. 제네릭 자료형 하나면 어떤 자료형의 객체를 만드는 빌더냐에 관계없이 모든 빌더에 적용할 수 있다.

빌더 패턴에도 단점은 있다.
객체를 생성하려면 우선 빌더 객체를 생성해야 한다는 오버헤드가 있다. 또한 점층적 생성자 패턴보다 많은 코드를 요구하기 때문에 인자가 충분히 많은 상황(가령 네개이상)에서 이용해야 한다. 


요약하자면 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적인자인 상황에 유용하다.
