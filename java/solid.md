# 객체지향 설계 5대 원칙 (SOLID)

1. SRP (Single Responsibility Principle)
   __단일 책임의 원칙__
	- 하나의 모듈(변수, 클래스, 메소드, 모듈)은 하나의 책임만을 가져야 한다.
	- 왜? 그렇지 않으면 유지보수 비용이 많이든다.
	 * 만약 하나의 클래스가 너무많은 책임을 가진다면 -> 확산적 변경(Divergent Change)이 일어나야하고, 비용이 커진다.
	 * 만약 하나의 책임이 여러 개의 클래스에 분산되어 있다면 -> 수정 할 곳이 많아져 수정한 곳들이 너덜너덜해짐 (샷건에 의한 상처), 비용이 커진다.

2. OCP (Open Close Principle)
	__개방 폐쇄의 원칙__
	- 확장에는 열려있고 수정에는 닫혀있어야 한다
		예) rect 와 circle 만을 그리는 도형편집기에 triangle을 추가한다고해서 기존 코드에 수정이 일어나면 안된다.
	- "새로운 기능이 추가되어도 기존 코드는 수정되면 안된다."
	- 객체 지향 설계의 목표점
	* OCP를 만족하는 객체지향 언어의 기능
		1) 인터페이스, 추상클래스
		2) 오버라이딩 -> 다형성 (런타임에 결정)
		3) 오버로딩  -> 다형성 (컴파일 타임에 결정)

3. LSP (Liscov Substitution Principle)
	__리스코프 치환(대체)의 법칙__
	- 자식은 부모를 대체할 수 있어야한다.
	- 자식의 공통된 기능은 부모 클래스로부터 와야한다.
	- 부모 레퍼런스를 통해 자식의 기능을 이용할 수 있다.-> 다형성

4. ISP (Interface Segreation Principle)
	__인터페이스 분리의 법칙__
	* 인터페이스란? 구현은 없고 명세만 있는것 / 인터페이스를 사용하면 느슨한결합 곧 OCP를 만족할 수 있다.

		인터페이스|상속
		--------|--------
		기능 상속 | 기능과 구현상속
	* 인터페이스의 문제점 : 인터페이스가 추가되거나 변경되면 모든 자식클래스가 수정되어야 한다.
					   -> 깨지기 쉬운 자식 클래스의 문제가 발생한다. 
	* 범용 인터페이스 보다는 세분화된 인터페이스가 낫다.

5. DIP (Dependency Inversion Principle)
	__의존관계 역전의 법칙__
	* 구체클래스에 의존하기보단 추상클래스나 인터페이스에 의존해야한다.
	* 만약 A라는 클래스에서 B클래스를 참조하는 모듈이 있다면 이는 강한결합을 형성하고있는것. 
		-> 예) C로 변경하고싶다면 A클래스에서 B클래스에 관한 코드수정이 일어나야 한다.
			   하지만 B,C클래스가 구현하고 있는 인터페이스를 참조하게 해놓는다면 코드의 수정이 불필요해진다.
	