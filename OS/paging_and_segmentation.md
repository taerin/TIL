# 페이징(Paging)과 세그멘테이션(Segmentation)
한 프로세스의 논리 주소 공간을 여러 개로 분할하여 비연속적인 물리 메모리 공간에 할당하는 방식

## 페이징(Paging)
페이지 단위의 논리- 물리 주소 관리 기법을 말한다. 논리 주소 공간이 하나의 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 방법.

* 필요 조건 : 논리 주소 공간과 물리 주소 공간을 분리(주소의 동적 재배치 허용), 논리주소와 물리주소 변환을 위한 전용 하드웨어(MMU)

* 페이지 테이블은 설령 페이지가 몇개 안되더라도 32비트 기준 4GB에 해당하는 페이지 갯수만큼의 크기를 가진다. 그 이유는 인덱스로 빠르게 접근하여 맵핑하기 위해서이다.

* 논리 주소 : 페이지 번호(p)와 페이지 오프셋 (d, offset)로 구성되어 있다.

* 페이징의 특징 : 외부 단편화 없다. 페이지 크기가 클수록 내부 단편화는 커질 수 있다. 반대로, 페이지 크기가 작으면 내부 단편화는 작아지지만 페이지 테이블의 크기가 커지게된다.

* 페이지 테이블은 메모리에 저장되어 있다. 따라서 MMU는  메모리에서 페이지 테이블을 가져와 주소를 변환하여야 하므로 코스트가 배가 된다. 이를 해결하기 위해 MMU 내부에 TLB라는 페이지 전용 캐시를 두고 사용한다.

* ASID(Address-space Identifier) : TLB의 문맥 교환 비용을 조금이나마 줄여보기 위한 방법. TLB에 페이지 넘버와 페이지 프레임 번호 앞에 프로세스 아이디를 같이 저장해서, TLB를 매번 flush하지 않고 그냥 덮어 써버리는 방식으로 flush하는 코스트를 줄인다.

-> TLB에 케싱 히트율이 98%라도 약 22% 정도 가량의 성능 저하가 있다. 히트율이 99% 이상이어야 유효하다.

## 페이지 테이블의 구조
32비트 컴퓨터 기준으로 페이지 테이블의 크기는 약 4MB정도로 꽤 크다. 따라서 이러한 페이지 테이블을 연속된 순서로 할당하는 것이 힘들다. 이를 해결하기 위한 다양한 시도들을 알아보자.

### 계층적 페이징
페이지 테이블을 여러 작은 덩어리로 쪼갠다. 이렇게 되면 연속되지 않기 때문에 인덱스로 직접 접근 할 수 없게 된다. 따라서 이 쪼개진 페이지 테이블들의 위치를 가지고 있는 outer page table을 하나 더 두는 방식.

페이지 접근 시간이 늘어나는 치명적인 단점이 있는 방식.

예) 전교생을 운동장에 반끼리 세우기 / 무작위로 세우기
-> 용량은 똑같지만 찾을 때 용이

### 해쉬 페이지 테이블
즉, 100만개의 페이지가 있다 하더라도 사실상 사용하는 페이지는 얼마 되지 않는다. 따라서 헤시테이블을 구성해 링크드 리스트로 페이지 정보를 가지고 있으면 성능 저하가 적음에도 저장 공간을 확 줄일 수 있다.

### 역 페이지 테이블
물리 메모리의 프레임 번호로 인덱스되는 테이블

역 페이지 테이블에서는 메모리 프레임마다 한 항목씩을 할당한다. 각 항목은 프레임에 올라와 있는 페이지 주소, 그리고 그 페이지를 소유하고 있는 프로세스ID를 표시하고 있다. 이렇게 되면 시스템에는 단 하나의 페이지 테이블만이존재하게 되고 테이블 내 각 항목은 메모리 한 프레임씩을 가리키게 된다.

논리 페이지마다 항목을 가지는 대신 물리 프레임에 대응되는 항목만 테이블에 저장하기 때문에 메모리에서훨씬 작은 공간을 점유 한다. 단점으로는 역 페이지 테이블은 주소 변환 시간이 더 오래 걸릴 수 있으며 프레임에 따라 저장되어있어 탐색은 비효율적이다.

## 세그멘테이션(Segmentation)
사용자/프로그래머 관점의 메모리 관리 기법. method, procedure, function, object, variables, stack 등 프로그램의 논리적 단위로 나누는 방법. 페이징 방법이 기계적으로 페이지 크기 만큼 일정한 크기로 나누는 것과 달리 세그멘테이션 방법은 프로그램의 논리적 단위를 잘 나눠 주어 서로 침범하지 못하게 보호해주는 방법이다. 일반적으로 세그멘테이션을 하여 다시 페이징을 하는 방식으로 페이징과 세그멘테이션을 같이 활용하여 시스템을 구현한다.


