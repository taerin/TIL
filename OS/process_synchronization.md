# 프로세스 동기화
공유 자원은 병행하여 접근하게 되면 자료의 불일치가 발생한다. 자원의 일관성 유지를 위해 협력하는 프로세스들이 올바른 순서로 수행을 보장하는 매커니즘이 필요하다.

## Race condition(경쟁 조건)
여러개의 프로세스가 동일한 자원을 접근하여 조작하고, 그 실행결과가 접근이 발생한 특정 순서에 의존하는 상황으로, 경쟁 상황으로부터 보호하기 위해 한 순간에 하나의 프로세스만이 공유 자원을 조작하도록 보장하기 위해 프로세스를 동기화 해야한다. __ 프로세스가 어떤 순서로 스케쥴링 되느냐에 따라 값이 달라질 수 있는 상황의 코드__

## 원자적 연산(Atomic operation)
쪼갤 수 없는 연산으로 어떤 연산의 결과가 외부의 간섭에 관게없이 전체가 완료되든지 전혀 실행되지 않은 상태로만 나타난다.
원자적 연산을 해야하는 부분 앞뒤에는 표시(flag)를 해야한다.

## 임계 영역(Critical Section)
race condition이 발생할 수 있는 프로그램 코드 부분을 말한다. 

## 임계 영역 문제 해결을 위한 요구 조건
	1. 상호 배제 (Mutual Exclusion) : 프로세스 p가 자기의 임계구역에서 실행 된다면 다른 프로세스들은 그 임계 영역으로 들어올 수 없다.

	2. 진행(Progress) : 자기의 임계구역에서 실행되는 프로세스가 없고, 자신의 임계 구역으로 진입하려고 하는 프로세스들이 있다면 이들 프로세스들 중 하나는 유한한 시간내에 진입할 수 있어야한다. 예를 들어 코딩을 잘못하여 임계 영역이 아님에도 계속해서 다른 프로세스를 막도록 해서는 안된다는 의미.

	3. 한정된 대기(Bounded waiting) : 한 프로세스가 자신의 임계영역에 진입하려는 요청을 한 후부터 그 요청이 허용되기 전까지 다른 프로세스들이 그 임계구역에 진입이 허용되는 횟수에 제한이 있어야 한다. 즉 임계영역에 대한 진입 요청 후 무한히 기다리지 않는다. 상호배제를 통해 일관성이 깨지는 것을 해결했다 하더라도, 스케쥴링 특성에 의해 하나의 프로세스만 계속해서 동작하고 다른 프로세스틑 계속 block 되서는 올바르게 해결 했다고 볼 수 없기 때문이다. 즉 wating에도 순서가 있어야 한다는 말!

## 동기화의 기본적인 해결 방법(임계 영역 진입 부분을 안전하게 처리 하는 법)
	1. 임계 영역으로 진입 가능성 확인과 진입을 원자적으로 처리
	- 경쟁 조건이 발생하지 않도록 함.
	- 진입하게 되면 임계 영역을 잠금(lock) (Lock은 동기화의 가장 근본적인 수단이다!)

	2. 경쟁 조건이 발생하더라도 안전하게 처리.
	결국 lock을 위해 flag를 표시를 할텐데, 이 flag도 결국은 또 다시 공유하게 되는 변수인 것이다. 따라서 재귀적으로(?) 또 다시 같은 문제에 봉착하게 된다. 이를 해결하기 위한 고전적 알고리즘으로는 피터슨 알고리즘, 데커 알고리즘이 있다.

##  동기화를 위한 하드웨어
중간에 인터럽트 되지 않는 명령어를 제공한다. 즉, 임계 영역 문제가 발생 하는 이유는 여러 개의 명령어를 원자적으로 처리를 해야한다는 것인데, 앞서 살펴본 바와 같이 결국은 원자적으로 처리하기위한 lock 표시를 하는 flag도 임계 영역의 문제와 연결된다.
이를 해결하는 방법으로 애초 하드웨어적으로 lock을 구현하는 것이다. 즉, 보통 상황에서 여러개의 명령어로 동작 하는 것을 하나의 명령어로 동작할수 있도록 구현해 lock상황에서만 사용을 하는 것이다.(왜냐하면 이런 하드웨어적 구현은 복잡하여 성능이 떨어지므로, lock상황에서만 문제 해결을 위해 사용하는 것이다.) 

##  세마포어
검사 연산: wait(S) – P(S) 락(lock)의 획득(S는 세마포어 변수)
증가 연산: signal(S) – V(S)  락(lock)의 해제

락인지 아닌지를 점검하기 위해서는 그저 0, 1로만 구분을 하면 되지만, 세마포어는 좀 더 일반적인 상황에서의 사용을 위해 integer값을 사용한다. 예를 들어 공유 자원 중 하나인 프린터가 3개 있다고 했을 때, 내가 프린터를 사용한다고해서 다른 사람들의 프린터 사용을 모두 막아버린다면 몹시 비합리적이다. 이럴 경우 단지 0, 1이 아니라 3개의 열쇠를 만들어 놓고 사용 중일 경우 그 열쇠의 갯수를 하나 줄이고, lock을 해제 하였을 경우 열쇠 갯수를 다시 하나 증가 시키는 방식으로 사용하면 이런 문제가 해결될 것이다.

세마포어도 역시 세마포어 변수 그 자체가 공유되는 변수이므로 임계 영역의 문제가 마찬가지로 발생한다. 이를 해결 하는 방법으로는 앞서 살펴본 하드웨어적인 방법을 사용한다.(TestAndSet 함수와 같이 하드웨어 레벨에서 제공하는 lock 방법을 사용) 또는, wait(), signal() 실행 중에 인터럽트를 금지해버리는 방법을 사용해버릴 수 도 있다. 하지만 인터럽트를 금지하는 방법은 컴퓨터 시스템에서 굉장히 위험한 작업이긴하다.

### 세마포어의 치명적인 문제
Busy waiting 문제(spin lock) - 프로세스가 lock을 기다리는 동안 계속 순환하면서 CPU를 점유하고 있는 문제 발생(자원 낭비)
-> Busy waiting을 blocking연산으로 수정하여 해결한다.(waiting 상태에 빠지도록 만듬)

## 동기화로 인해 발생하는 문제
하나의 프로세스 입장에서 자기 자신만 생각하고 lock을 걸어버릴 때 나타날 수 있는 문제가 데드락이다.
