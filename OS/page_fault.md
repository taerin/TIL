# 가상 메모리 
먼저 가상 주소 공간(Virtual address space)이라는 새로운 개념에 대하여 알아봅시다. 가상 주소 공간이란 어플리케이션이 사용가능한 최대 주소 공간을 말합니다. 
아키텍쳐에 따라서 주소지정을 위해 필요한 비트수가 달라지기 때문에 가상 주소 공간은 어느 아키텍쳐냐에 따라 달라집니다. 또 운영체제의 구현 방식으로 인해서도 달라질 수 있습니다.
가상주소 공간에서 '가상'이라는 단어는 어플리케이션이 사용가능한 고유 주소 지정메모리 위치의 총 숫자를 의미합니다. 그러나 시스템에 설치된 물리적 메모리의 양이나 어플리케이션에 주어진 물리적 메모리의 양을 의미하지는 않습니다.

가상 메모리를 구현하기 위해서는 컴퓨터가 특수 메모리 관리 하드웨어를 갖추고 있어야만 합니다. 이 하드웨어는 MMU(Memory Management Unit)라고 부르기도 합니다. MMU가 없이는 CPU가 RAM에 접근할 때 실제 RAM의 위치가 절대 변경되지 않기 때문에 메모리 주소 123은 RAM에서도 동일한 물리적 주소를 갖게됩니다.

MMU를 사용하는 경우 각 메모리에 접근하기 이전에 메모리 주소 번역 작업을 수행합니다. 즉 메모리 주소 123가 한번은 물리적 주소 82043으로 지정되었다가 다음엔 물리적 주소 20468로 지정될 수 있다는 것을 의미합니다. 
그러나 수억만 바이트에 이르는 메모리를 하나씩 가상 주소에서 물리적 주소로 번역하게되면 작업 부하가 너무 높아지므로, MMU는 RAM을 여러 부분 — 페이지(pages)로 나누어 각 페이지를 하나의 독립된 항목으로 처리합니다.
이 페이지 및 주소 번역 정보를 기억하는 작업은 복잡하고 불필요해 보일 수도 있습니다. 그러나 이 작업은 가상 메모리를 구현하는데 결정적인 절차입니다. 
앞서 설명해왔던 15000 바이트 가상 주소 공간을 가진 가상 어플리케이션을 예로 들겠습니다. 이 어플리케이션의 첫번째 명령어가 주소 12374에 저장된 데이터에 접근한다고 가정해봅시다. 그러나 컴퓨터에는 오직 12288 바이트의 물리적 RAM만 존재하는 경우 CPU가 주소 12374에 접근 시도한다면 어떠한 결과가 발생하겠습니까?

이러한 현상을 __페이지 폴트(page fault)__라고 부릅니다.

# Page Fault
페이지 폴트란 프로그램이 자신의 주소 공간에는 존재하지만 시스템의 RAM에는 현재 없는 데이터나 코드에 접근 시도하였을 경우 발생하는 현상을 말합니다. 페이지 폴트가 발생하면 운영 체제는 그 데이터를 메모리로 가져와서 마치 페이지 폴트가 전혀 발생하지 않은 것처럼 프로그램이 계속적으로 작동하게 해줍니다.

예를 들어보자면, 한 어플리케이션의 경우 CPU는 우선 원하는 주소 (12374)를 MMU에게 보냅니다. 그러나 MMU에는 이 주소 변환 과정에서 페이지 테이블에 이 주소에 대한 항목이 없다고 표시되어 있습니다. 따라서 MMU는 CPU를 인터럽트한 후 페이지 폴트 처리기라는 소프트웨어가 실행되도록 합니다. 이 페이지 폴트 처리기는 다음과 같은 기능을 이용하여 이 페이지 폴트 문제를 해결하기 위한 방법을 찾습니다:

* 원하는 페이지가 디스크 상 어디에 위치하는지 찾은 후 읽어오기 (일반적으로 페이지 폴트가 코드 페이지일 경우)
* 원하는 페이지가 이미 RAM에 존재하지만 아직 현재 프로세스에는 할당되지 않았는지 확인 후 MMU가 그 주소를 찾도록 재설정하기
* 0만 담고 있는 특수 페이지를 지정 후 프로세스가 이 특수 페이지에 쓰기 시도할 경우에만 새 페이지를 할당하기 (이러한 특수 페이지는 copy on write 페이지라고 부르며, 종종 0으로 시작된 데이터를 담고 있는 페이지에 사용됩니다)
* 원하는 페이지를 다른 곳에서 가져오기

첫 세가지 작업은 상대적으로 단순하지만, 마지막 작업은 그렇지 않습니다. 따라서 이 마지막 작업을 설명하기 위해서는 추가 항목들도 함께 논의해야합니다.

## 작업 세트(Working Set)
현재 특수 프로세스 전용으로 할당된 물리적 메모리 페이지 그룹을 그 프로세스의 작업 세트(working set)라고 합니다. 작업 세트에 포함된 페이지 수는 시스템 전반에 걸쳐 사용 가능한 총 페이지 수에 따라서 증가되거나 줄어듭니다.
프로세스 페이지 폴트가 발생할때마다 작업 세트가 증가되며, 여유 페이지 수가 줄어들면 작업 세트도 작아집니다. 메모리 완전 부족 현상을 방지하기 위해서는 프로세스의 작업 세트에서 페이지를 삭제하여 나중에 사용 가능한 여유 공간으로 변경시켜야 합니다. 운영 체제는 다음과 같은 방법을 사용하여 프로세스의 작업 세트를 줄여줍니다:

* 수정된 페이지를 대용량 기억장치(하드)의 전용 공간 (보통 스와핑(swapping) 또는 페이징(paging) 공간이라고 부름)에 기록하기
* 수정되지 않는 페이지는 여유 페이지로 표시함(이 페이지는 변경되지 않았으므로 디스크로 가져와 기록할 필요가 없습니다)

운영 체제는 모든 프로세스에 적절한 작업 세트를 할당하기 위하여 모든 페이지에 대한 사용 정보를 기록해야 합니다. 이렇게 함으로서 운영 체제는 어느 페이지가 자주 사용되었으며 (이러한 페이지는 메모리에 계속 두어야합니다) 어느 페이지가 사용되지 않았는지 (따라서 메모리에서 삭제할 수 있습니다) 결정할 수 있습니다. 대부분의 경우 프로세스 작업 세트에서 최근 가장 자주 사용되지 않은 페이지를 찾아서 삭제합니다.

## 스와핑
스와핑 (수정된 페이지를 시스템 스왑 페이지에 기록하는 작업)은 시스템 작업의 일부분으로서, 스와핑이 과도하게 일어나는 경우도 발생 가능합니다. 다음과 같은 상황이 반복적으로 발생할 수 있기 때문에 과도한 스와핑 작업을 신중하게 살펴야 합니다.

* 프로세스에서 페이지가 스와핑됨
* 프로세스가 실행 가능 상태가 되어 스왑된 페이지에 접근 시도함
* 페이지 폴트로 메모리로 다시 기록됨 (대부분의 경우 다른 프로세스 페이지가 스왑핑되어 나가게됨)
* 얼마 지나지 않아 이 페이지가 다시 스와핑됨

만일 이러한 상황이 너무 자주 발생하게되는 경우를 쓰래싱(thrashing)이라고 하며 현재 작업을 실행하는데 RAM이 부족하다는 것을 나타냅니다.
쓰레싱이 발생시 시스템이 처리할 수 있는 것보다 더 많은 CPU및 입/출력 작업을 무리하게 실행시키려하여 프로그램의 처리 속도가 급격히 떨어지게 됩니다. 극단적인 경우엔 시스템은 아무런 작업도 실행하지 못한채, 페이지를 메모리에서 가져오고 빼내는 작업에만 모든 자원을 소모하게되는 경우도 있습니다.

[출처](http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-memory-virt-details.html)
