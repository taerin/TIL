# 주소 지정
## 메모리 위치 및 메모리 주소
모든 메모리 위치는 주소를 가져야 한다. 일반적으로 각각의 메모리 위치는 8bit의 데이터를 저장한다. 각각의 주소는 특정 메모리 위치에 대한 고유 식별자이다.

## 주소 지정(addressability)
컴퓨터가 메모리 위치를 식별하는 방식을 '주소 지정'이라 한다.

## 메모리 위치
### 메모리 위치와 주소버스
주소 버스의 폭(width)이 주소 지정할 수 있는 메모리 위치의 최대 크기(갯수)를 결정한다. 1bit의 주소버스는 2개의 메모리 위치에 접근 할 수 있다.

### 버스(bus)
버스는 컴퓨터 용어로 컴퓨터의 내부나 외부의 각 장치와의 정보나 신호를 주고받는 데 사용되도록 구성된 전기적 통로를 말한다.
'주소 버스'는 주소값을 주고 받을 수 있는 '신호 통로'를 의미하며, 1bit 주소버스로는 1bit의 주소값을 주고 받을 수 있다.

## N bit 주소 버스
### 주소 버스 크기와 주소 지정
컴퓨터가 사용할 수 있는 '주소 지정' 가능한 범위는 '주소 버스'의 크기에 좌우된다. 2bit 주소버스는 4개, 3bit는 8개의 주소를 지정할 수 있다. 
일반적으로 32bit 컴퓨터라는 의미는 32bit 주소 버스를 가진 (혹은 그런 구조로 설계된) 컴퓨터 이다. 또한 64bit컴퓨터라고 해서 물리적으로 64bit address bus를 사용하는 것은아니다. 논리적 개념으로 이해해야한다. 

![memory bus](../images/memory_bus.png)

## 주소 지정 범위 = 2^n
* 8bit 주소 버스의 주소 지정 범위 = 2^8 = 256개의 메모리 위치
* 16bit 주소 버스의 주소 지정 범위 = 2^16 = 65,536개의 메모리 위치
* 32bit 주소 버스의 주소 지정 범위 = 2^32 = 4,294,967,296개의 메모리 위치 = 4GB
* 64bit 주소 버스의 주소 지정 범위 = 2^16 = 엄청난 숫자!

## 사용 가능한 메모리 용량
컴퓨터가 3bit의 주소버스를 가지고 있다면 8개의 메모리 위치를 사용할 수 있다. 그런데 얼마나 많은 메모리를 사용할 수 있을까?

질문에 답하기 위해서는 각각의 메모리 위치에 얼마나 많은 비트가 저장될 수 있는지를 알아야하고, 메모리 위치에 저장되는 데이터의 크기는 '데이터 버스'의 크기에 의해 결정된다.

만일 데이터 버스의 크기가 2bit라면 사용 가능한 메모리 용량은 8 * 2 = 16bit = 2byte가 된다.

# 메모리 관리법
## 메인 메모리
메모리는 각각 주소가 할당된 바이트 단위 데이터 공간으로 구성된다.

## CPU의 동작 방식
CPU는 PC(Program Counter) 레지스터가 가리키는 메모리 위치에 있는 다음 명령어를 가져온다.
그 이후 피연산자가 필요할 경우 메모리에서 또 가져오고 명령어를 실행한다. 
결과를 레지스터 혹은 메모리 저장하고 또 다음 명령을 가져온다.

## Register
CPU가 직접 접근 가능한 데이터 저장장치로 개별 레지스터는 고유 명칭과 용도가 지정되어 있는 단일 데이터 저장소이다.

## Main Memory
메인메모리는 복수의 데이터를 저장할 수 있으며, 주소 지정을 통해 개별 데이터를 읽고 쓸 수 있다.

## 실행(연산)을 위한 준비
모든 명령어와 자료들을 수행하기 위해선 CPU가 가져와야한다.
만약 보조기억장치나 다른 곳에 있다면 먼저 메모리로 옮긴 이후에 수행한다.

## 데이터 접근 속도
레지스터는 일반적으로 CPU 1clock cycle만에 접근 가능하다.
메모리는 일반적으로 CPU 2clock cycle 이상의 시간이 필요하다. 이때 데이터를 가져오는 동안 CPU가 아무 일도 못하는 현상도 발생한다. Cache memory등을 이용해 처리속도를 높이는 방법도 존재한다.


# 프로그램, 메모리, CPU
## 실행 프로그램
하드디스크에 저장되어있고, 실행시 프로그램의 코드와 데이터를 메인메모리로 복사한다. 메모리에 프로그램이 올랐을때의 상태를 프로세스라고 부른다.

## 메인 메모리와 CPU
운영체제를 포함한 복수의 프로그램이 메인메모리에 적재(load)된다.
CPU는 여러 레지스터를 이용해 실행중인 명령위치를 지정하고 프로그램을 실행한다.

# 주소 바인딩
## 주소결합 또는 주소 지정
프로그램이 보조기억장치(혹은 보조 저장장치)에 기록되어 있는 동안에는 메인메모리에 어느 위치에 load(적재)될지 알 수 없다. 따라서 프로그램이 메모리로 옮겨진 후에 명령과 데이터들의 주소가 확정(지정)되는 절차를 주소결합(address binding)이라고 부른다.

## 컴파일 시점 지정 (Compile time Binding)
프로그램이 메모리의 어느 위치에 적재될 지를 컴파일 타임에 미리 알 수 있다면 메모리 절대주소를 지정할 수 있따다. 운영체제의 boot loader (운영체제 시작 프로그램)는 절대 주소지정 방식을 이용한다.

## 적재 시점 지정 (Load Time Binding)
메모리 적재 위치를 컴파일 시간에 알 수 없다면, 프로그램이 메모리에 적재되는 시점에 주소 재배치 코드를 실행한다.
어플리케이션 프로그램(운영체제를 제외한)은 메인 메모리의 어느 위치에 적재될 지 알 수 없으므로 프로그램의 첫번쨰 명령을 기준으로 상대주소(relative address)를 컴파일 시점에 설정한다.
프로그램을 실행하면, 프로그램을 메모리에 적재하면서 절대 주소값을 재계산한다.

## 실행 시점 지정 (Excurion time Binding)
프로그램 실행중에 메모리 주소가 변경되는 방식이다. 하드웨어가 주소를 변경해주는 역할을 하기 때문에 하드웨어의 지원이 필요하다.

# MMU (Memory Management Unit)
논리주소(logical address)를 물리주소(physical address)로 변환(mapping)하는 하드웨어로 CPU에서 특정 논리 주소 위치에 저장된 데이터를 요청할 때 MMU가 자동으로 주소를 변환한다. 소프트웨어 프로그래머는 논리 주소만으로 작업할뿐 실제 물리적 주소위치는 알 수 없다.

# 동적 로딩(dynamic loading)
프로세스가 시작될 때 그 프로세스의 주소공간 전체를 메모리에 올려 놓는 것이 아니라, 메모리를 좀더 효율적으로 사용하기 위해 필요한 루틴(routine)이 호출될때 해당 루틴을 메모리에 적재하는 방식이다.
사용되지 않을 코드가 메모리에 올라가는 것을 막아 메모리의 낭비를 막는 기법이다. 동적로딩은 운영체제의 특별한 지원 없이 프로그램 자체에서 구현이 가능하며, 운영체제가 라이브러리를 이용해 지원할 수 도 있다. 

1. 주 메모리에 적재
2. 실행해야할 동적 루틴이 있을때, 메모리에 있는지 확인
3. 없을 경우 디스크에서 메모리에 적재 후 실행

# 스와핑(Swapping)
메모리에 적재된 프로세스의 메모리 공간 전체를 디스크의 스왑 영역(swap area)에 일시적으로 내려 두는 것을 말한다. 
이때, 스왑 영역을 backing store라고도 부르며, 디스크 내의 파일 시스템과는 별도로 존재하는 영역이다.
스왑 영역은 프로세스가 수행 중인 동안에만 디스크에 저장되는 공간이므로 저장 기간이 상대적으로 짧은 저장 공간이다.

* Swap In(Page In) - 디스크에서 메모리로 프로세스를 실행하기 위해 메모리로 옮기는 작업
* Swap Out(Page Out) - 메모리에서 프로세스를 일시적으로 하드디스크로 내려두는 작업

# 연속 할당(Continuous Allcation)
메인메모리는 두 영역으로 나뉘게 되는데 마로 운영체제와 사용자 프로세스다. 
* 운영체제: 인터럽트 벡터(Interrupt Vector)와 함께 하위 메모리 영역에 존재한다.
* 사용자 프로세스: 운영체제 보다 상위 메모리에 위치한다.

연속 할당은 각 프로세스는 메모리에 연속적인 한 블록(block)에 저장된다. 
이는 Base register 방식으로 사용자 프로세스 간에 간섭하지 못하도록 한다. 
* Base register는 가장 작은 물리 주소값을 포함한다.
* Limit register는 논리 주소의 크기를 포함한다.
* Limit register의 값보다 큰 위치의 주소를 참조(접근)할 수 없다.

즉 주소연산 수행시, 연속 할당된 범위를 벗어난 주소에 접근할 경우, 오류가 발생한다.

# 구멍과 할당 (Hole and Allocation)
## 구멍 (Hole)
사용 중이지 않은 할당가능한 영역으로 전체 메모리 중에서 사용자 프로세스(어플리케이션)이 할당되지 않은 영역을 말한다.

## 할당영역 vs 자유영역
운영체제는 실행중인 프로세스를 위해 할당된 부분(allocation partition)과 사용되고 있지 않은 자유영역(free partition = hole)을 관리한다.


