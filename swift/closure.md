# Clousure(클로져)

실제로 스위프트에서 클로저는 일회용 함수를 작성할 수 있는 구문입니다.
일회용 함수란 한 번만 사용할 수 있는 구문들의 집합이면서, 그 형식은 함수로 작성되어야 하는 제약조건이 있을 때 만들어 사용할 수 있는 함수를 이야기합니다. 
전통적인 명령형 언어에서는 모든 함수에 이름이 부여되어야 하지만 일회용 함수는 한번만 사용하면 되므로 굳이 함수의 이름을 작성할 필요없이 생갹된다는 점에서 익명(Anonymous)함수라고 부르기도합니다.
현존하는 많은 프로그래밍 언어에서 다양한 방식으로 일회용 함수를 제공하는데, 대표적인 예는 다음과 같습니다.

언어 | 일회용 함수
-----|------------
오브젝티브-C | 블록(Block)
자바스크립트 | 익명함수
자바 | 람다함수
파이썬 | 람다함수
Lisp | 람다 함수
스위프트 | 클로저

위 표현들 중에서 블록(Block)과 클로저를 제외하면 모두 비슷한 표현들입니다. 프로그래밍 언어에서는 람다(Lambda)를 익명 형식이라고 해석하는 경우도 있고, 축약형이라고 해석하는 경우도 있기 때문입니다. 그러니 혹시라도 익명함수와 람다함수는 다르다고 생각하지 맙시다.

클로저는 자신이 정의되었던 문맥(Context)으로부터, 모든 상수와 변수의 값을 캡처하거나 레퍼런스를 저장하는 익명함수라고 할 수 있습니다.
사실 스위프트에서 익명함수를 클로저라고 부르게 된 것도, 이러한 함수형 언어에서의 클로저 개념을 사용하고있기 때문이라고 할 수 있습니다. 

스위프트에서 클로저라고 부르는 객체는 대부분 다음 세 가지 경우 중 하나에 해당합니다.

* 전역함수 | 이름이 있으며 주변 환경에서 캡쳐할 어떤 값도 없는 클로저
* 중첩함수 | 이름이 있으며 자신을 둘러싼 함수로부터 값을 캡쳐할 수 있는 클로저
* 클로저 표현식 | 이름이 없으며 주변 환경으로부터 값을 캡쳐할 수 있는 경량 문법으로 작성된 클로저 입니다.

## 클로저 표현식
클로저 표현식은 함수와 달리 생략할 수 있는 부분이 많습니다. 우선, 함수를 선언하는 func 키워드를 생략하며, 함수의 이름 또한 생략합니다. 클로저 표현식은 일반 함수으 ㅣ선언 형식에서 func 키워드와 함수명을 제외한 나무지 부분만 작성하는 경량 문법을 사용합니다.

``` swift
{(매개변수) -> 반환타입 in
	실행할 구문
}
```
클로저 표현식은 중괄호 형태의 블록으로 시작되고, 닫는 블록으로 구문을 완료합니다. 클로저 표현식의 블록 내부에서 가장 먼저 작성하는 것은 함수의 인자 타입과 반환타입에 관한 정의입니다. 이 부분은 함수의 타입으로 표현할 수 있습니다. 일반적인 함수 정의라면 반환타입이 표현된 다음에는 실행 블록의 시작을 나타네는 중괄호가 와야하지만 , 클로저 표현식의 시작 부분에서 이미 중괄호가 선언된 상태이므로 중괄호 대신 in 키워드를 사용하여 실행 블록의 시작을 표현합니다. 

in키워드 다음부터 클로저 포현식의 실행블록이 작성되는 것이죠. 클로저 표현식의 실행 블록 작성이 모두 끝나면 중괄호로 닫으면 됩니다. 실제로 사용되는 예를 알아봅시다.

``` swift
{() -> () in
	print("클로저가 실행됩니다")
}
```

위 예제에서 작성하는 함수는 인자값과 반환값이 없는 함수입니다. 반환값이 없을 때는 일반 함수처럼 반환값타입을 생략하는 것이 아니라, 함수 타입을 표현하는 것처럼 빈 괄호를 사용하여 반환값이 없음을 명시적으로 표현해야 합니다. 이는 클로저 표현식의 간결성을 위해 반환 타입을 생략할 수 있기 때문입니다. 

클로저 표현식에서 반환타입이 있기는 하지만 생략된 경우와, 반환값이 아예 없어서 작성되지 않은 경우를 컴파일러가 구분할 때 모호한 기준이 생길 수 있습니다. 이와 같은 경우를 방지하기 위해 반환값이 없는 경우 이를 명시적으로 표현해 줄 수 있도록 한 것입니다. 빈 괄호로 작성된 반환 타입은 다음과 같이 타입 알리어스로 작성된 문자열 Void를 이용해서 표현할 수도 있습니다.

``` swift
{ () -> Void in
	print("클로저가 실행됩니다.")
}
```

위 예에서는 줄 바꿈이 되어있으나 이는 클로저 표현식의 구문을 명료하게 제시해 주기 위한 것으로, 실제로 클로저 표현식을 사용할 때는 한 줄에서 작성하여도 무방합니다.

작성된 클로저 표현식은 그 자체로 함수라고 할수 있습니다. 클로저 표현식은 대부분 인자값으로 함수를 넘겨주어야 할 때 사용하지만, 직접 실행해 볼 수도 있습니다. 이를 위한 두가지 방법이 제공되는데, 첫 번째 방법은 일급 함수로서의 특성을 활용하여 상수나 변수에 클로저 표현식을 할당한 다음 실행하는 방법입니다.

``` swift
let f = { () -> Void in
	print("클로저가 실행됩니다")
	}

f()
// 클로저가 실행됩니다
```

위 구문은 실제로 함수의 인자값으로 전달된 클로저 표현식이 함수 내에서 실행되는 방식입니다. 함수 f에 클로저 표현식으로 작성된 함수 전체가 할당되고, 이 상수에 함수 호출 연산자를 추가함으로써 클로저 표현식이 실행됩니다.

``` swift
({ () -> Void in
	print("클로저가 실행됩니다")
})()
// 클로저가 실행됩니다.
```

두 번째 방법은 클로저 표현식을 할당받을 상수 f 마저 생략하고 싶을 때 작성하는 구문입니다. 클로저 표현식 전체를 소괄호로 감싸고, 여기에 함수 호풀 연산자를 붙이면 클로저 표현식이 실행됩니다. 클로저 표현식 전체를 소괄호로 감싸지 않으면 컴파일러에서는 이 구문을 클로저 표현식의 정의가 아니라 그 실행값을 변수나 상수에 할당하려는 의도로 해석하여 오류를 발생시키므로 주의해야 합니다.

이번에는 매개변수가 있는 형태의 클로저 표현식을 알아봅시다.

``` swift
let c = {(s1: Int, s2 : String) -> Void in
		print("s1 : \(s1), s2: \(s2))
	}

c(1, "closure")
// "s1 :1, s2: "closure"
```
여기서 매개변수 s1과 s2는 클로저의 실행 블록내부에서 상수로 선언되므로 실행 구문 범위내에서 사용할 수 있습니다. 위 예제는 다음과 같이 보다 간결하게 작성될 수 있습니다.


``` swift
({ (s1: Int, s2 : String) -> Void in
	print("s1 : \(s1), s2: \(s2))
}) (1, "closure")
```

상수 c에 할당하는 과정이 생략되어 전체적으로는 더 간결해졌지만, 아무래도 조금은 읽기 어려워진 모습입니다.


## 클로저 표현식과 경량 문법
클로저 표현식은 주로 인자값으로 사용되는 객체인 만큼 간결성을 극대화하기 위해 생략할 수 있는 구문들로 이루어져 있습니다.
학습을 위해 배열 하나를 작성하겠습니다. 

``` swift
let value = [1,9,5,7,3,2]
```

이 배열은 정렬 함수인 sort(_:)를 이용하여 큰 순서나 작은 순서대로, 또는 임의의 순서대로 정렬 할 수 있는데, 이때 정렬의 기준을 삼기위해 함수를 인자값으로 받습니다. 함수는 두 개의 인자값을 받고, 이 인자값들을 비교하여 어느 쪽이 더큰지 결과값을 Bool 형식으로 반환해야 합니다.
sort(_:) 메소드에서 인자값으로 사용되는 함수도 두 값을 받아 Bool타입의 결과값을 반환하는 형식으로 구성되어야합니다.

``` swift
func order (s1: Int, s2: Int) -> Bool {
	if s1 > s2 {
		return true
	} else {
		return false
	}
}

value.sort(order)
```
위 코드는 내림차순 정렬을 해주는 코드입니다. 이제 함수 order를 클로저 표현식으로 바꾸어 작성해 보겠습니다.

``` swift
{ (s1 : Int, s2: Int) -> Bool in
	if s1 > s2 {
		return true
	} else {
		return false
	}
}
```

정수형 인자값 두 개를 입력받고, 반환 값으로 Bool 타입을 반환하는 클로저 표현식으로서, 입력받은 인자 값은 s1, s2를 비교하여 s1이 더 크다면 true를 이외의 경우에는 false를 반환하는 역할을 합니다. 이 클로저 표현식은 sort메소드의 인자값으로 바로 사용할 수 있습니다.

``` swift
value.sort( { (s1 : Int, s2: Int) -> Bool in
	if s1 > s2 {
		return true
	} else {
		return false
	}
})
```

위 코드는 더 간결하게 작성될 수도 있습니다.

``` swift
value.sort({ (s1: Int, s2: Int) -> Bool in return s1 > s2})
```

클로저 표현식은 반환값의 타입을 생략할 수 있습니다. 반환타입을 생략하면 컴파일러는 클로저 표현식의 구문을 해석하여 반환값을 찾고 이 값의 타입을 추론하여 클로저의 반환 타입을 정의합니다.

``` swift
{ (s1: Int, s2: Int) -> 
in return s1 > s2
}
```

이정도 만으로도 충분히 간결하지만 클로저 표현식에서 s1, s2 라는 매개변수의 타입 어노테이션을 생략할 수 있습니다. 생략된 매개변수 타입은 컴파일러가 실제로 대입되는 값을 기반으로 추론해냅니다.

``` swift
{s1, s2 in return s1 > s2}
```

이제는 매개변수 마저 생략해 봅시다. 매개변수가 생략되면 매개변수명 대신 $0, $1, $2 와 같은 이름으로 할당된 내부 상수를 이용할 수 있습니다. 이 값은 입력받은 인자값의 순서대로 매칭됩니다. 

매개변수가 생략되면 남는 것은 실행구문입니다. 이 때문에 in 키워드로 기존처럼 실행구문과 클로저 선언부분을 분리할 필요가 없어지므로 in 키워드 역시 생략할 수 있습니다. 결국 남는 것은 다음과 같습니다.

``` swift
{return $0 > $1 }
```

이것은 입력받은 인자값을 순서대로 비교하여 결과값을 반환하게 만들죠. 그러나 어차피 Bool 값을 반환할 것을 컴파일러가 알고있으며(sort 메소드의 인자값 타입을 통하여), 비교연산자의 결과가 if 구문과 같은 조건문에서 사용되지 않은 점 역시 컴파일러가 반환 타입을 추론할 수 있는 단서입니다. 따라서 return 구문까지 생략되죠. 남은 구문만을 정리해 보면 결국, 다음과 같은 형식의 클로저 표현식이 인자로 사용되는 결과를 얻게 됩니다.

``` swift
value.sort( {$0 > $1} )
```

사실 sort 메소드에서는 클로저 표현식보다 더 간결하게 포현할 수 있는 방법도 있습니다. 이를 연산자함수 (Operator Functions)라고 부르는데, 연산자 만을 사용하여 의미하는 바를 정확히 나타낼 수 있을 때 사용됩니다. 이를 이용하여 최종적으로 sort메소드를 정리해보면 다음과 같습니다.

``` swift
value.sort(>)
```

* 클래스나 구조체 내부에서 함수가 정의되어있을때 특별히 Method 라고한다.




