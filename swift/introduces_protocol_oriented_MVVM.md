https://news.realm.io/kr/news/doios-natasha-murashev-protocol-oriented-mvvm
# Introduces protocol-oriented MVVM
Swift에서 레퍼런스 타입 대신 밸류 타입을 사용하는 것은 Objective-C 보다 쉬우며, 이해하기 쉽고 에러가 적은 코드로 개선하는데 도움이 됩니다. 그러나 공유해서 사용해야 하는 상황에서는 이런 장점을 살리지 못하고 subclassing을 하는 실수를 하기 쉽습니다. do{iOS} 2015에서 MVVM에 대해 소개한 이 강연에서, 프로토콜을 사용하는 방법과 subclass에서 벗어나는 방법을 알아 보세요. 프로토콜 지향 프로그래밍에 대해 익히고 적용하는 등, Swift 2.0의 장점을 살리고 코드를 개선하기 위해 Natasha가 학습한 과정을 차근차근 설명해 줍니다.

## Swift에서는 왜 코드를 단순화할까요?
objective-C를 사용하는 개발자로써, 처음 Swift가 나왔을 땐 Swift 내부에 Objective-C 코드를 쓰는 방식으로 시작했고 레퍼런스 타입을 사용했습니다. 객체 지향 프로그래밍이 익숙했으므로 모든 것을 클래스로 만드는 것부터 시작하곤 했습니다. 마치 Objective-C의 태생처럼요.

그때까지만 해도 가끔 normal enum보다 복잡한 enum을 사용하기도 했기 때문에 나름 만족하고 있었습니다. 하지만 여러 행사와 강연을 다니고, 특히 Swift 복잡성 제어와 밸류 타입에 대한 [Andy Matuschak의 강연](https://news.realm.io/news/andy-matuschak-controlling-complexity/) 을 듣고 나자 생각이 확 달라졌습니다. 그때까지는 Swift의 struct를 알고는 있었지만 Swift로 넘어간 Objective-C 개발자로써 클래스가 훨씬 더 자연스러웠죠.
그 인상적인 강연을 들은 후에는, 이제 모든 것에 밸류 타입을 사용해야겠다고 생각했습니다. 강연에서 밸류 타입을 사용하는 Swift 표준 라이브러리를 보여줬고, 언어 창시자들도 밸류 타입을 사용하니까요. 제 작업을 열어서 새 파일을 만들고 밸류 타입으로부터 시작해 봤습니다.

처음에는 “와, 나는 Swift 개발자야, struct를 사용하지!” 하는 마음에 즐거웠지만 subclass를 만들어야 하는 시점에서 괴로워졌고, 어떻게 이 장벽을 넘어서야 할지 모르겠더군요. 그러다가…

## 프로토콜 지향 프로그래밍
2015년 WWDC의 한 멋진 강연에서 Swift의 프로토콜 지향 프로그래밍을 만났습니다! subclass 대신 프로토콜을 사용하는 방법을 알 수 있있죠. Swift에 적응해가는 분이라면 작년 WWDC 중 이 강연이 가장 유용할 겁니다.

이 강연에서 Apple의 Swift 표준 라이브러리 tech lead인 Dave Abrahams는 이렇게 말했습니다.

> “Swift는 프로토콜 지향 프로그래밍 언어입니다.”

강연에서 그는 저를 포함한 모든 관중을 완전히 사로잡았습니다.

table view처럼 Apple이 사용하는 다양한 프로토콜을 보아 왔으므로 이것이 완전히 새로운 개념은 아닐 겁니다. 특히 사용할 때마다 UITableViewController를 subclassing하지 않아도 된다는 점에서 멋진 디자인 패턴이죠. Apple에 table view cell을 몇 개 만들지 알려주는 프로토콜을 사용하면 그만입니다. 자, 이제 이런 디자인 패턴의 위대함을 알았으니 더 나아가 볼까요?

프로토콜 지향 프로그래밍에 큰 감명을 받은 저는 프로토콜 지향 프로그래머가 되고 싶었습니다. 제 작업을 돌아보니 이미 정립된 패턴을 사용한 코드베이스가 보이더군요. 새로운 것을 적용하는 것 이전에 무엇을 사용해야 할지 아는 것부터가 어려웠습니다. 이미 존재하는 프로젝트에 갇힌 느낌이 들었고 이미 알고 있는 것에서 어떻게 개선해가야 할지 몰랐습니다.


## 심사숙고 후 깨달은 사용예 - MVVM
저는 프로토콜을 제 코드에 통합할 방법을 몇 날 며칠 내내 생각했습니다. 그러다 잠에서 깨어난 어느날 모든 것이 하나로 연결된 기분이 들었습니다. 제 코드에 적용할 수 있는 최소 하나의 사용예를 찾아낸 것이죠. 바로 MVVM이었습니다.

우선 간단한 예제를 보여드리겠습니다.

계좌 잔고를 보여주는 원본 데이터를 가진 모델이 있다고 가정해 보죠. 모델 레이어에서 원본 NSDecimalNumber로 값을 저장합니다.

``` swift
let amount = 6729383.99
```

같은 숫자이지만 사용자에게는 “계좌 잔고는 이렇습니다.” 하고 안내하듯 잘 가공해서 보여줘야겠죠. 통화 단위도 붙이고요.

``` swift
Your balance is $6,729,383.99
```

흔히 이 코드를 뷰 컨트롤러에 붙이는데, 그러면 뷰 컨트롤러가 무거워지고 테스트가 어려워집니다. 대신 이를 모델에 붙인다면 이번엔 모델이 복잡해지겠죠.

한편 모델을 명료하게 유지하고 원본 데이터를 반영할 수 있는 뷰 모델을 한번 볼까요?

``` swift
struct AccountViewModel {
	let displayBalance: String

		init(mode: BankAccount) {
			let formattedBalance = model.balance.currencyValue
			displayBalance = "Your balance is \(formattedBalance)"
		}
}
```

모델을 포함하는 이 뷰 모델을 통해 정보를 뷰에 보여지기 원하는 형식으로 구성할 수 있습니다. 게다가 테스트도 쉽죠. 이 방법 대신 계좌 정보를 모델에 넣을 수도 있겠지만 출력값이 명료하지 않기 때문에 뷰 컨트롤러나 뷰를 테스트하기 어렵습니다.



