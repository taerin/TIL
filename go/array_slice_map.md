# 배열 / 슬라이스 / 맵
# 1. 배열
배열은 길이가 고정된, 번호가 매겨진 단일 타입 원소의 나열이다. Go에서는 다음과 같은 형태다.

``` go
var x [5]int
```

x는 5개의 int 타입으로 구성된 배열의 예다.

``` go
package main

import "fmt"

func main() {
	var x [5]int
	x[4] = 100
	fmt.Println(x)
}
```

출력 결과는 다음과 같다.

``` go
[0 0 0 0 100]
```

Go에서는 배열을 생성하는 더 짧은 문법도 제공한다.

``` go
x := [5]float64{ 98, 93, 77, 82, 83 }
```
# 2. 슬라이스
슬라이스(slice)는 배열의 일부다. 배열과 마찬가지로 슬라이스도 인덱스를 통해 접근할 수 있고 길이가 있다. 하지만 배열과 달리 슬라이스의 길이는 바뀔 수 있다. 다음은 슬라이스의 예다.

``` go
var x []float64
```

슬라이스와 배열의 유일한 차이점은 대괄호 사이에 길이가 없다는 것이다. 이 경우 x는 길이가 0인 상태로 생성된다.

슬라이스를 생성하고 싶다면 내장 함수인 make를 사용하면 된다.

```go
x := make([]float64, 5)
```

이렇게 하면 기저에 길이가 5인 float64 배열과 연관된 슬라이스가 만들어진다. 슬라이스는 항상 그것과 연관된 배열이 있고, 해당 배열보다 절대로 길어질 수는 없지만 더 작아질 수는 있다. make 함수에는 세 번째 매개변수를 전달할 수도 있다.

``` go
x := make([]float64, 5, 10)
```

[][][][][][][][][][][][]
--실제x--
=======점유 공간========

슬라이스를 만드는 또 다른 방법은 [low : high] 수식을 사용하는 것이다.

``` go
arr := []float64{1,2,3,4,5}
a := arr[0:5]
```

low는 슬라이스가 시작되는 인덱스이고, high는 슬라이스가 끝나는 인덱스다(인덱스 자체는 포함하지 않는다).
예를 들어 arr[0:5]는 [1,2,3,4,5]를 반환하는 데 반해 arr[1:4]는 [2,3,4]를 반환한다.

편의를 위해 low나 high를 생략하거나 심지어 low와 high를 모두 생략할 수도 있다.
arr[0:]은 arr[0:len(arr)]와 같고 arr[:5]는 arr[0:5]와 같으며, arr[:]은 arr[0:len(arr)]과 같다.

## 슬라이스 함수
Go에는 append와 copy라는 슬라이스를 사용하는 데 도움이 되는 두 가지 내장 함수가 포함돼 있다. 다음은 append를 사용하는 예제다.

``` go
func main() {
	slice1 := []int{1,2,3}
	slice2 := append(slice1, 4, 5)
	fmt.Println(slice1, slice2)
}
```
이 프로그램을 실행하면 slice1은 [1,2,3]이 되고 slice2는 [1,2,3,4,5]가 된다. append는 기존 슬라이스(첫 번째 인자)를 가져와서 그다음에 이어지는 인자를 모두 거기에 덧붙이는 식으로 새 슬라이스를 생성한다.

다음은 copy를 사용하는 예제다.

``` go
func main() {
	slice1 := []int{1,2,3}
	slice2 := make([]int, 2)
	copy(slice2, slice1)
	fmt.Println(slice1, slice2)
}
```

이 프로그램을 실행하면 slice1은 [1,2,3]이 되고 slice2는 [1,2]가 된다. slice1의 내용은 slice2로 복사되는데, slice2에는 두 요소가 들어갈 만한 공간밖에 없어서 slice1의 첫 두 요소만 복사된다.

# 3. 맵



[출처](http://www.codingnuri.com/golang-book/6.html)
