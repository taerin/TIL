# Promotion

``` c
char ch = 0xFF;
int size = 0xFFFFFF;

if(ch == size) 
{
	printf("same\n");
} else {
	printf("diff\n");
}

```

위 코드를 실행하면 어떤 값이 나올까? 
결과는 "same" 이다.

1byte의 char 타입과, 4byte의 int가 만나면 더 큰쪽의 타입으로 promotion이 일어나게 되는데,
1byte에서 4byte로 변경되는 방법은 다음과 같다.

변수 ch 값인 0xFF를 2진수로 표현하게 되면 1111 1111 이다.
int 타입의 변수 size 값 0xFFFFFF을 2진수로 나타내면 1111 1111 1111 1111 이다.

char가 int로 프로모션이 일어나게 되면,
 					1111 1111 에서
0000 0000 1111 1111 로 
앞 비트가 0으로 채워지며 일어날 것 같지만 그렇지 않다.
부호비트를 유지하여 0 대신 1을 채우며 

					1111 1111 에서
1111 1111 1111 1111 로 변경되어 버린다.
그러므로 변수 size의 값과 동일하게 된다.

그럼 이번엔 아래 코드는 어떨까? 
``` c
// ch의 타입이 int로 변경되었다. 
int ch = 0xFF;
int size = 0xFFFFFF;

if(ch == size) 
{
	printf("same\n");
} else {
	printf("diff\n");
}
```

ch의 값인 16진수값을 2진수로 변경하면 
0000 0000 1111 1111 이 되어
size의 2진수 값인
1111 1111 1111 1111 과 다르게 된다.

이 경우를 왜 기억해야 하냐면, 윈도우에서 사용할때 c언어는(표준은 아니지만) 파일의 모드를 "wb" 나 "wt" 로 지정하는 경우가 있다.
이경우는 바이너리 파일(b) 과 텍스트파일(t)를 구별하기 위함이지만, linux에서는 바이너리파일과 텍스트파일을 모두 동일하게 취급하기 때문에 모드 지정시 "w", "r" 과 같이 부가적인 파일 종류를 붙일 필요가 없다.
만약 파일을 fgetc() 함수를 통해 1byte씩 읽으며 카운트하여 파일의 사이즈를 측정하는 함수를 만들었다고 해보자.
파일의 끝이 도달했을때는 프로그램을 종료하며 파일 사이즈를 출력하도록 해야하기 때문에 파일을 읽을때 EOF(int -1)와 만나면 함수를 탈출한다는 반복문 탈출조건을 작성해야 한다. 
하지만 만약 fgetc() 함수가 int를 리턴한다는 것을 깜빡하고, char 타입의 변수에 return 값을 받도록 해두었다면 char 타입의 변수에는 -1 값이 들어가게 되어 EOF(int -1)의 여부를 판단할때, 위 코드와 같은 오류를 범하게 되어 char -1 과 int의 -1을 동일하다 오판하게 된다. 
그렇게 되면 파일의 끝이 아닌데도 끝으로 판단되어 제대로된 프로그램을 작성 할 수 없는 문제가 발생하게 된다.
