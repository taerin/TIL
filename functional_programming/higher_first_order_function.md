# Higher-order function (고계함수)
	고계함수란 함수를 다루는 함수를 뜻합니다. 
	사실 함수형 언어에서는 함수도 '값(value)'으로 취급합니다.
	그러므로 정수 1이나 인수를 제곱하는 함수나 동등한 입장에서 다룰 수 있습니다. 
	정수를 함수의 인수로 전달 할 수 있듯이 어떤 함수도 다른 함수의 인수로 전달 할 수 있다는 뜻입니다. 
	마찬가지로 함수의 결과값으로 함수를 반환할 수도 있는것이죠!

	예를들어서 1에서 10까지 숫자로 이루어진 리스트의 각 원소를 제곱하고 싶다고 해봅시다. 
	명령형 언어에서는 반복문을 이용하여 리스트를 훑어가며 각 원소를 제곱하겠지만, 
	함수형 언어에서는 리스트를 다루는 고계함수로 이를 처리할 수 있습니다.
``` haskell
map (\x -> x * x) [1..10]
```
여기서 [1..10] 은 1에서 10까지 숫자로 이루어진 리스트입니다. 
고계함수 map은 첫번째 인수로 주어진 함수(여기서는 제곱을 수행하는 익명함수)를 두번째 인수로 주어진 리스트의 각 원소에 적용한 결과 리스트를 반환합니다. 
위 코드를 수행하면 다음과 같은 결과를 얻을 수 있습니다.
``` haskell
[1,4,9,16,25,36,49,64,81,100]
```

	* 하스켈: 순수 함수형 프로그래밍 언어

# First-class function (일급 함수)
	JavaScript의 함수는 1급 객체(first class object)입니다.
	* 1급 시민(first class citizen)란? 
		1) 변수(variable)에 담을 수 있다
		2) 인자(parameter)로 전달할 수 있다
		3) 반환값(return value)으로 전달할 수 있다
대부분의 프로그래밍 언어에서 숫자는 1금 시민의 조건을 충족한다. 숫자는 변수에 저장 할 수 있고 인자나 반환값으로 전달할 수 있다.

#### 1급 객체(first class object)
	1급 객체(first class object)라는 것은 특정 언어에서 객체(object)를 1급 시민으로써 취급한다는 뜻입니다. 
	당연히 위의 조건을 모두 충족하게 됩니다.

#### 1급 함수(first class function)
	1급 객체 뿐만 아니라 1급 함수도 존재합니다. 
	함수를 1급 시민으로 취급하는 것이죠! 
	몇몇의 학자들은 1급 시민의 조건과 함께 다음과 같은 **추가적인 조건**을 요구합니다.
		* 런타임(runtime) 생성이 가능하다
		* 익명(anonymous)으로 생성이 가능하다
	이러한 추가적인 조건을 봤을때 C언어의 함수는 1급 함수로 볼 수 없습니다.

### 그렇다면 JavaScript의 함수는 1급 함수? 1급 객체?
	JavaScript에서는 객체를 1급 시민으로 취급합니다.
	그리고 JavaScript의 함수도 객체로써 관리되므로 1급 객체라고 볼 수 있습니다.
	동시에 JavaScript의 함수는 1급 함수의 추가조건도 만족합니다.

	이렇게 1급 객체인 동시에 1급 함수이지만, 보통 1급 객체로 기술하는 편인듯하다. 아마 함수가 객체이기 때문이지 않을까 싶다.

### JavaScript에서 함수가 1급 객체인 것이 중요한 이유
	함수가 1급 객체라는 사실은 겉으로 봤을 땐 그리 특별하지 않습니다만
	함수를 그냥 주고받을 수 있다는 것 뿐이지만 이것이 아주 큰 차이점을 만듭니다.

	가장 중요한 장점은 바로 고차 함수(high order function)가 가능하다는 점이입니다. JavaScript의 each, filter, map, sort 등의 함수들이 얼마나 편리한지는 잘 알고 있을 것입니다. 
	인자로 목적에 맞는 함수를 하나 넘겨주면 아주 쉽게 처리가 됩니다.
	반면, Java 7의 Collections.sort함수같은 경우도 비교를 위해 인자를 하나 넘겨주게 되는데,
	이것은 함수가 아니라 Comparator interface 타입의 인스턴스(instance)입니다 -> 비교자!. 
	함수 하나를 넘겨주기 위해서 새로운 클래스를 만들고 그것의 인스턴스까지 생성해야 하는 것입니다. -> 이는 ES6와 Java 8에서는 람다(lambda)가 지원되면서 훨신 간편해졌습니다.

	1급 객체가 JavaScript의 클로져(closure)와 만나면 또 하나의 장점이 생깁니다.
	JavaScript의 함수는 생성될 당시의 Lexical Environment를 기억하게 되는데, 함수를 주고받게 되면 이 Lexical Environment도 함께 전달됩니다. 
	이것을 이용해서 커링(currying)과 메모이제이션(memoization)이 가능해집니다.


## 일급함수
일급함수는 다음과 같은 특징을 갖으며 데이터처럼 취급할 수 있는 함수를 말합니다.

1. 변수에 저장할 수 있다.
2. 배열의 항목으로 저장할 수 있다.
3. 객체 필드로 저장할 수 있다.
4. 원하는 만큼 생성할 수 있다.
5. 다른 함수로 전달할 수 있다.
6. 함수로부터 반환될 수 있다.
